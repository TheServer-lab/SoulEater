<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Soul Eater — Fixed</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body { margin:0; overflow:hidden; background:#0b0b0b; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: white; }
  canvas { display:block; }

  /* UI */
  #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
  #ui-layer > * { pointer-events: auto; }

  #menu {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background: rgba(20,20,20,0.95); padding: 26px; border-radius: 12px;
    text-align: center; border: 2px solid #4ea3ff; box-shadow: 0 0 20px rgba(78,163,255,0.2);
  }
  input, button { display:block; width:100%; margin:8px 0; padding:10px; border-radius:6px; border:none; font-size:15px; }
  input[type="text"] { background:#333; color:#fff; width:200px; margin:6px auto; }
  input[type="color"] { height:40px; cursor:pointer; }
  button { background:#4ea3ff; color:#fff; cursor:pointer; font-weight:700; }
  button:hover { background:#3a89e0; }

  #leaderboard {
    position: fixed; top: 10px; right: 10px;
    background: rgba(0,0,0,0.5); padding: 12px; border-radius: 6px;
    min-width: 160px; font-family: monospace;
  }
  .lb-entry { display:flex; justify-content:space-between; gap:12px; margin-bottom:4px; }
  .lb-rank { color:#aaa; }

  .label { font-size:12px; color:#aaa; text-align:left; margin-top:6px; }

  /* Powerup UI */
  #powerup-ui {
    position: fixed; left: 10px; top: 10px; color:#fff; font-size:14px;
    background: rgba(0,0,0,0.35); padding:8px 10px; border-radius:8px;
    min-width:180px;
  }
  .pu-item { display:flex; align-items:center; gap:8px; margin-bottom:6px; }
  .pu-icon { width:20px; height:20px; border-radius:4px; display:inline-block; }
  .pu-bar { height:6px; background:#222; border-radius:4px; overflow:hidden; flex:1; }
  .pu-fill { height:100%; background:#4ea3ff; width:0%; }

  #controls-hint { font-size:12px; color:#bbb; margin-top:8px; }

  @media (max-width:520px){
    #menu { width:90%; padding:18px; }
    #leaderboard { min-width:120px; font-size:13px; }
  }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="ui-layer">
  <div id="menu">
    <h1 id="menu-title">SOUL EATER</h1>
    <div class="label">PLAYER NAME</div>
    <input type="text" id="playerName" value="SoulsSeeker" maxlength="12">
    <div class="label">SOUL COLOR</div>
    <input type="color" id="playerColor" value="#4ea3ff">
    <button id="startBtn">START HARVESTING</button>
    <button id="restartBtn" style="display:none;">RESTART</button>
    <div id="controls-hint">Mouse to steer; WASD / arrows for keyboard. Collect power-ups for temporary boosts.</div>
  </div>

  <div id="leaderboard" style="display:none;">
    <div style="font-weight:bold; border-bottom:1px solid #555; margin-bottom:8px;">LEADERBOARD</div>
    <div id="lb-content"></div>
  </div>

  <div id="powerup-ui" style="display:none;">
    <div style="font-weight:bold; margin-bottom:6px;">POWER-UPS</div>
    <div id="pu-list"></div>
  </div>
</div>

<script>
/* =========================
   CONFIG & STATE
========================= */
const WORLD_SIZE = 4000;
const INITIAL_FOOD = 400;
const BOT_COUNT = 18;
let gameActive = false;

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const menu = document.getElementById("menu");
const menuTitle = document.getElementById("menu-title");
const startBtn = document.getElementById("startBtn");
const restartBtn = document.getElementById("restartBtn");
const lbUI = document.getElementById("leaderboard");
const lbContent = document.getElementById("lb-content");
const powerupUI = document.getElementById("powerup-ui");
const puList = document.getElementById("pu-list");

function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
addEventListener("resize", resize);
resize();

const rand = (a,b)=>Math.random()*(b-a)+a;
const dist = (a,b)=>Math.hypot(a.x-b.x,a.y-b.y);

/* =========================
   AUDIO (WebAudio synth SFX)
========================= */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playTone(freq, type='sine', duration=0.08, gain=0.12, pan=0){
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  const p = audioCtx.createStereoPanner();
  o.type = type;
  o.frequency.value = freq;
  g.gain.value = gain;
  o.connect(g);
  g.connect(p);
  p.connect(audioCtx.destination);
  p.pan.value = pan;
  o.start();
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
  setTimeout(()=>{ try{ o.stop(); }catch(e){} }, duration*1000 + 20);
}
function eatSound(){ playTone(520,'triangle',0.06,0.08,0); setTimeout(()=>playTone(720,'sine',0.06,0.06,0),60); }
function pickupSound(){ playTone(880,'sine',0.12,0.12,-0.2); setTimeout(()=>playTone(660,'triangle',0.08,0.08,0.2),90); }
function deathSound(){ playTone(220,'sawtooth',0.25,0.18,0); setTimeout(()=>playTone(120,'sine',0.35,0.12,0),120); }

/* =========================
   ENTITIES
========================= */
const player = { x:0, y:0, r:28, speed:2.5, color:"#4ea3ff", name:"You", alive:false, speedMult:1, magnet:false };

const food = [];
const bots = [];
const botNames = ["Zeta","Nova","Echo","Vex","Luna","Rex","Pico","Orbit","Flare","Shadow","Void","Specter","Nyx","Kite","Astra","Rune","Mira","Bolt"];

const powerups = [];
const POWERUP_TYPES = { SPEED: 'speed', MAGNET: 'magnet' };

const particles = [];
const MAX_PARTICLES = 700;

/* =========================
   SPAWN HELPERS
========================= */
function spawnFood(n=1){
  for(let i=0;i<n;i++){
    food.push({
      x:rand(-WORLD_SIZE/2,WORLD_SIZE/2),
      y:rand(-WORLD_SIZE/2,WORLD_SIZE/2),
      r:rand(3,5),
      color: `hsl(${rand(0,360)},70%,60%)`
    });
  }
}

function spawnBot(role=null){
  const r = rand(18, 46);
  const roleAssigned = role || (Math.random() < 0.45 ? 'hunter' : 'gatherer');
  const color = roleAssigned === 'hunter' ? `hsl(${rand(0,40)},70%,55%)` : `hsl(${rand(160,260)},60%,55%)`;
  bots.push({
    x:rand(-WORLD_SIZE/2,WORLD_SIZE/2),
    y:rand(-WORLD_SIZE/2,WORLD_SIZE/2),
    r,
    speed: rand(1.4, 2.4),
    color,
    name: botNames[Math.floor(Math.random()*botNames.length)],
    alive: true,
    role: roleAssigned,
    aggression: roleAssigned === 'hunter' ? rand(0.6,1.0) : rand(0.0,0.5)
  });
}

function spawnPowerup(type, x=null, y=null){
  const px = x ?? rand(-WORLD_SIZE/2, WORLD_SIZE/2);
  const py = y ?? rand(-WORLD_SIZE/2, WORLD_SIZE/2);
  powerups.push({ x:px, y:py, type, ttl: 60 * 20 });
}

/* =========================
   INPUT
========================= */
const mouse = { x:0, y:0 };
addEventListener("mousemove", e => { mouse.x = e.clientX - canvas.width/2; mouse.y = e.clientY - canvas.height/2; });

const keys = { w:false,a:false,s:false,d:false, up:false,down:false,left:false,right:false };
addEventListener('keydown', e => {
  const k = e.key.toLowerCase();
  if(k === 'w' || e.key === 'arrowup') keys.w = keys.up = true;
  if(k === 's' || e.key === 'arrowdown') keys.s = keys.down = true;
  if(k === 'a' || e.key === 'arrowleft') keys.a = keys.left = true;
  if(k === 'd' || e.key === 'arrowright') keys.d = keys.right = true;
});
addEventListener('keyup', e => {
  const k = e.key.toLowerCase();
  if(k === 'w' || e.key === 'arrowup') keys.w = keys.up = false;
  if(k === 's' || e.key === 'arrowdown') keys.s = keys.down = false;
  if(k === 'a' || e.key === 'arrowleft') keys.a = keys.left = false;
  if(k === 'd' || e.key === 'arrowright') keys.d = keys.right = false;
});

function getInputAngle(){
  let vx = 0, vy = 0;
  if(keys.w || keys.up) vy -= 1;
  if(keys.s || keys.down) vy += 1;
  if(keys.a || keys.left) vx -= 1;
  if(keys.d || keys.right) vx += 1;
  if(vx !== 0 || vy !== 0) return Math.atan2(vy, vx);
  return Math.atan2(mouse.y, mouse.x);
}

/* =========================
   START / RESTART
========================= */
function startGame(){
  if(audioCtx.state === 'suspended') audioCtx.resume();

  menuTitle.innerText = "SOUL EATER";
  player.name = document.getElementById("playerName").value || "Nameless";
  player.color = document.getElementById("playerColor").value;
  player.alive = true;
  player.x = 0; player.y = 0; player.r = 28;
  player.speedMult = 1; player.magnet = false;

  gameActive = true;
  menu.style.display = "none";
  lbUI.style.display = "block";
  powerupUI.style.display = "block";
  restartBtn.style.display = "inline-block";

  food.length = 0; bots.length = 0; powerups.length = 0; particles.length = 0;
  spawnFood(INITIAL_FOOD);
  for(let i=0;i<BOT_COUNT;i++) spawnBot();
  spawnPowerup(POWERUP_TYPES.SPEED);
  spawnPowerup(POWERUP_TYPES.MAGNET);
  updateLeaderboard();
}
startBtn.addEventListener('click', startGame);
restartBtn.addEventListener('click', startGame);

/* =========================
   PARTICLES
========================= */
function spawnParticles(x,y,color,count=10,spread=2.2,vel=2.2){
  for(let i=0;i<count;i++){
    if(particles.length > MAX_PARTICLES) break;
    const angle = Math.random()*Math.PI*2;
    const speed = Math.random()*vel;
    particles.push({
      x, y,
      vx: Math.cos(angle)*speed*spread,
      vy: Math.sin(angle)*speed*spread,
      life: Math.floor(rand(30, 80)),
      maxLife: 80,
      color
    });
  }
}
function updateParticles(){
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.x += p.vx; p.y += p.vy;
    p.vx *= 0.98; p.vy *= 0.98; p.vy += 0.02;
    p.life--;
    if(p.life <= 0) particles.splice(i,1);
  }
}
function drawParticles(){
  particles.forEach(p=>{
    const alpha = Math.max(0, p.life / p.maxLife);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x-1.5, p.y-1.5, 3, 3);
  });
  ctx.globalAlpha = 1;
}

/* =========================
   GAME LOGIC
========================= */
const activePowerups = {}; // {speed:{remaining}, magnet:{remaining}}

function applyPowerupToPlayer(type){
  const DURATION_FRAMES = 60 * 8;
  if(type === POWERUP_TYPES.SPEED){
    player.speedMult = 1.9;
    activePowerups.speed = { remaining: DURATION_FRAMES };
  } else if(type === POWERUP_TYPES.MAGNET){
    player.magnet = true;
    activePowerups.magnet = { remaining: DURATION_FRAMES };
  }
  powerupUI.style.display = "block";
  pickupSound();
}

function updatePowerupTimers(){
  for(const k of Object.keys(activePowerups)){
    activePowerups[k].remaining--;
    if(activePowerups[k].remaining <= 0){
      if(k === 'speed') player.speedMult = 1;
      if(k === 'magnet') player.magnet = false;
      delete activePowerups[k];
    }
  }
}

function updatePowerupUI(){
  updatePowerupTimers();
  const entries = [];
  if(activePowerups.speed) entries.push({ key:'speed', label:'Speed Boost', color:'#ffd166', remaining: activePowerups.speed.remaining });
  if(activePowerups.magnet) entries.push({ key:'magnet', label:'Magnet', color:'#8be9a8', remaining: activePowerups.magnet.remaining });
  if(entries.length === 0){
    puList.innerHTML = '';
    if(!gameActive) powerupUI.style.display = "none";
    return;
  }
  puList.innerHTML = entries.map(e => {
    const pct = Math.max(0, Math.min(100, Math.floor((e.remaining / (60*8)) * 100)));
    return `
      <div class="pu-item">
        <div class="pu-icon" style="background:${e.color}"></div>
        <div style="flex:1">
          <div style="font-size:13px">${e.label}</div>
          <div class="pu-bar"><div class="pu-fill" style="width:${pct}%"></div></div>
        </div>
      </div>
    `;
  }).join('');
}

function update(){
  if(!gameActive) return;

  // Player movement
  if(player.alive){
    const angle = getInputAngle();
    const s = player.speed * player.speedMult * (1 - player.r/1000);
    player.x += Math.cos(angle)*s;
    player.y += Math.sin(angle)*s;
    player.x = Math.max(-WORLD_SIZE/2, Math.min(WORLD_SIZE/2, player.x));
    player.y = Math.max(-WORLD_SIZE/2, Math.min(WORLD_SIZE/2, player.y));
  }

  // Bots
  bots.forEach(bot => {
    if(!bot.alive) return;
    let angle = Math.random()*Math.PI*2;
    let target = null;
    let minD = 500;

    if(bot.role === 'hunter'){
      if(player.alive && player.r < bot.r * (1 + bot.aggression*0.1)) target = player;
      if(!target){
        for(let i=0;i<bots.length;i++){
          const other = bots[i];
          if(other === bot) continue;
          const d = Math.hypot(other.x-bot.x, other.y-bot.y);
          if(d < minD && bot.r > other.r * 1.08) { minD = d; target = other; }
        }
      }
      if(!target){
        for(let i=0;i<food.length;i++){
          const f = food[i];
          const d = Math.hypot(f.x-bot.x, f.y-bot.y);
          if(d < minD) { minD = d; target = f; }
        }
      }
    } else {
      for(let i=0;i<food.length;i++){
        const f = food[i];
        const d = Math.hypot(f.x-bot.x, f.y-bot.y);
        if(d < minD) { minD = d; target = f; }
      }
      if(player.alive && player.r < bot.r * 0.6 && Math.hypot(player.x-bot.x, player.y-bot.y) < 220){
        angle = Math.atan2(bot.y - player.y, bot.x - player.x);
        target = null;
      }
    }

    if(target) angle = Math.atan2(target.y - bot.y, target.x - bot.x);

    const s = bot.speed * (1 - bot.r/1000);
    bot.x += Math.cos(angle)*s;
    bot.y += Math.sin(angle)*s;
    bot.x = Math.max(-WORLD_SIZE/2, Math.min(WORLD_SIZE/2, bot.x));
    bot.y = Math.max(-WORLD_SIZE/2, Math.min(WORLD_SIZE/2, bot.y));
  });

  // Collisions & pickups
  checkEating(player);
  bots.forEach(bot => checkEating(bot));

  // Powerups TTL and pickup
  for(let i=powerups.length-1;i>=0;i--){
    const pu = powerups[i];
    pu.ttl--;
    if(pu.ttl <= 0) { powerups.splice(i,1); continue; }
    if(player.alive && Math.hypot(player.x-pu.x, player.y-pu.y) < player.r + 8){
      applyPowerupToPlayer(pu.type);
      spawnParticles(pu.x, pu.y, pu.type === POWERUP_TYPES.SPEED ? '#ffd166' : '#8be9a8', 18, 2.6, 2.8);
      powerups.splice(i,1);
    }
  }

  // occasional powerups
  if(Math.random() < 0.002 && powerups.length < 4) {
    spawnPowerup(Math.random() < 0.5 ? POWERUP_TYPES.SPEED : POWERUP_TYPES.MAGNET);
  }

  // magnet effect
  if(player.magnet){
    const magnetRange = 220;
    for(let i=0;i<food.length;i++){
      const f = food[i];
      const d = Math.hypot(f.x-player.x, f.y-player.y);
      if(d < magnetRange){
        const ang = Math.atan2(player.y - f.y, player.x - f.x);
        f.x += Math.cos(ang) * (2 + (magnetRange - d)/40);
        f.y += Math.sin(ang) * (2 + (magnetRange - d)/40);
      }
    }
  }

  updateParticles();
  updatePowerupUI();

  if(frameCount % 30 === 0) updateLeaderboard();
}

/* =========================
   COLLISIONS & EATING (FIXED)
   - More forgiving size and overlap checks so eating bots works reliably
========================= */
function checkEating(entity) {
  if(!entity.alive && entity !== player) return;

  // Eat Food
  for (let i = food.length - 1; i >= 0; i--) {
    if (dist(entity, food[i]) < entity.r) {
      entity.r += 0.38;
      spawnParticles(food[i].x, food[i].y, food[i].color, 8, 1.6, 1.6);
      if (entity === player) eatSound();
      food.splice(i, 1);
      if (food.length < INITIAL_FOOD) spawnFood(1);
    }
  }

  // Eat others (bots / player)
  let enemies = [...bots];
  if (entity !== player && player.alive) enemies.push(player);

  // Tweakable parameters
  const SIZE_MULTIPLIER = 1.05;   // attacker must be this times larger than target (5%)
  const OVERLAP_MARGIN = 0.2;     // allow some overlap: distance < attacker.r - target.r * OVERLAP_MARGIN

  enemies.forEach(target => {
    if (target === entity) return;
    const d = dist(entity, target);

    // More intuitive overlap test: attacker must be noticeably larger and close enough
    const canEatBySize = entity.r > target.r * SIZE_MULTIPLIER;
    const overlapThreshold = Math.max(6, entity.r - target.r * OVERLAP_MARGIN);
    const closeEnough = d < overlapThreshold;

    if (canEatBySize && closeEnough) {
      // Grow attacker
      entity.r += target.r * 0.42;

      // Visual / audio feedback
      spawnParticles(target.x, target.y, target.color || '#fff', 18, 2.4, 3.0);
      if (entity === player) eatSound();

      if (target === player) {
        // Player was eaten
        player.alive = false;
        gameActive = false;
        menu.style.display = "block";
        lbUI.style.display = "none";
        menuTitle.innerText = "DEVOURED!";
        restartBtn.style.display = "inline-block";
        deathSound();
      } else {
        // Remove eaten bot and spawn a replacement
        const idx = bots.indexOf(target);
        if (idx > -1) bots.splice(idx, 1);
        spawnBot();
      }
    }
  });
}

/* =========================
   LEADERBOARD
========================= */
function updateLeaderboard(){
  let all = [...bots];
  if(player.alive) all.push(player);
  all.sort((a,b) => b.r - a.r);
  lbContent.innerHTML = all.slice(0,10).map((ent,i) => `
    <div class="lb-entry" style="color:${ent === player ? '#fff' : '#aaa'}">
      <span><span class="lb-rank">${i+1}.</span> ${ent.name}${ent.role ? ' • ' + ent.role.toUpperCase() : ''}</span>
      <span>${Math.floor(ent.r)}</span>
    </div>
  `).join('');
}

/* =========================
   RENDERING
========================= */
let frameCount = 0;
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  if(!gameActive && !player.alive){
    ctx.save();
    ctx.translate(canvas.width/2, canvas.height/2);
    drawBackgroundStatic();
    ctx.restore();
    return;
  }

  ctx.save();
  ctx.translate(canvas.width/2 - player.x, canvas.height/2 - player.y);

  drawBackground();

  food.forEach(f => {
    ctx.fillStyle = f.color;
    ctx.beginPath(); ctx.arc(f.x, f.y, f.r, 0, Math.PI*2); ctx.fill();
  });

  powerups.forEach(pu => {
    ctx.save();
    ctx.translate(pu.x, pu.y);
    ctx.beginPath();
    if(pu.type === POWERUP_TYPES.SPEED){
      ctx.fillStyle = '#ffd166';
      ctx.arc(0,0,10,0,Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#000';
      ctx.font = 'bold 10px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('S', 0, 3);
    } else {
      ctx.fillStyle = '#8be9a8';
      ctx.arc(0,0,10,0,Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#000';
      ctx.font = 'bold 10px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('M', 0, 3);
    }
    ctx.restore();
  });

  bots.forEach(b => drawEntity(b));
  if(player.alive) drawEntity(player);

  drawParticles();

  ctx.restore();

  drawMinimap();

  frameCount++;
}

function drawBackground(){
  ctx.strokeStyle = "#1a1a1a";
  ctx.lineWidth = 2;
  const step = 100;
  for(let x = -WORLD_SIZE/2; x <= WORLD_SIZE/2; x += step){
    ctx.beginPath(); ctx.moveTo(x, -WORLD_SIZE/2); ctx.lineTo(x, WORLD_SIZE/2); ctx.stroke();
  }
  for(let y = -WORLD_SIZE/2; y <= WORLD_SIZE/2; y += step){
    ctx.beginPath(); ctx.moveTo(-WORLD_SIZE/2, y); ctx.lineTo(WORLD_SIZE/2, y); ctx.stroke();
  }
  ctx.strokeStyle = player.color;
  ctx.lineWidth = 10;
  ctx.strokeRect(-WORLD_SIZE/2, -WORLD_SIZE/2, WORLD_SIZE, WORLD_SIZE);
}

function drawBackgroundStatic(){
  ctx.fillStyle = "#070707";
  ctx.fillRect(-canvas.width/2, -canvas.height/2, canvas.width, canvas.height);
  ctx.strokeStyle = "#1a1a1a";
  ctx.lineWidth = 1;
  const step = 120;
  for(let x = -WORLD_SIZE/2; x <= WORLD_SIZE/2; x += step){
    ctx.beginPath(); ctx.moveTo(x, -WORLD_SIZE/2); ctx.lineTo(x, WORLD_SIZE/2); ctx.stroke();
  }
  ctx.strokeStyle = player.color;
  ctx.lineWidth = 8;
  ctx.strokeRect(-WORLD_SIZE/2, -WORLD_SIZE/2, WORLD_SIZE, WORLD_SIZE);
}

function drawEntity(e){
  ctx.fillStyle = e.color;
  ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); ctx.fill();

  if(e.role){
    ctx.fillStyle = e.role === 'hunter' ? 'rgba(255,120,80,0.9)' : 'rgba(140,200,255,0.9)';
    ctx.beginPath();
    ctx.arc(e.x + e.r*0.6, e.y - e.r*0.6, Math.max(4, e.r*0.18), 0, Math.PI*2);
    ctx.fill();
  }

  ctx.fillStyle = "white";
  ctx.font = `bold ${Math.max(12, e.r/2)}px Arial`;
  ctx.textAlign = "center";
  ctx.fillText(e.name, e.x, e.y + (e.r/4));
}

function drawMinimap(){
  const size = 150;
  const margin = 18;
  const x = margin;
  const y = canvas.height - size - margin;

  ctx.fillStyle = "rgba(0,0,0,0.7)";
  ctx.fillRect(x, y, size, size);
  ctx.strokeStyle = "#555";
  ctx.strokeRect(x, y, size, size);

  const scale = size / WORLD_SIZE;
  const mapCenter = size/2;

  bots.forEach(b => {
    ctx.fillStyle = b.color;
    ctx.fillRect(x + mapCenter + b.x*scale - 1, y + mapCenter + b.y*scale - 1, 3, 3);
  });

  powerups.forEach(pu => {
    ctx.fillStyle = pu.type === POWERUP_TYPES.SPEED ? '#ffd166' : '#8be9a8';
    ctx.fillRect(x + mapCenter + pu.x*scale - 2, y + mapCenter + pu.y*scale - 2, 4, 4);
  });

  if(player.alive){
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.arc(x + mapCenter + player.x*scale, y + mapCenter + player.y*scale, 3, 0, Math.PI*2);
    ctx.fill();
  }
}

/* =========================
   MAIN LOOP
========================= */
function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();

/* =========================
   INITIAL WORLD (pre-start)
========================= */
spawnFood(INITIAL_FOOD);
for(let i=0;i<Math.floor(BOT_COUNT*0.6);i++) spawnBot('gatherer');
for(let i=0;i<Math.floor(BOT_COUNT*0.4);i++) spawnBot('hunter');

/* =========================
   PERIODIC TICK
========================= */
setInterval(()=>{
  if(food.length < INITIAL_FOOD) spawnFood(INITIAL_FOOD - food.length);
  if(Math.random() < 0.08 && powerups.length < 5) spawnPowerup(Math.random() < 0.5 ? POWERUP_TYPES.SPEED : POWERUP_TYPES.MAGNET);
}, 1000);
</script>
</body>
</html>
